// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "./GameToken.sol";
import "@openzeppelin/contracts/security/ReentrancyGuard.sol";

contract TokenStore is ReentrancyGuard {
    IERC20 public usdt;
    GameToken public gt;
    address public operator; // backend owner (optional)

    event Purchased(address indexed buyer, uint256 usdtAmount, uint256 gtAmount);

    constructor(address _usdt, address _gt) {
        usdt = IERC20(_usdt);
        gt = GameToken(_gt);
        operator = msg.sender;
    }

    modifier onlyOperator() {
        require(msg.sender == operator, "only operator");
        _;
    }

    function setOperator(address op) external onlyOperator {
        operator = op;
    }

    /// Buyer must approve USDT to this contract before calling buy
    function buy(uint256 usdtAmount) external nonReentrant {
        require(usdtAmount > 0, "zero amount");
        // calculate GT amount using gtPerUsdt stored in token
        uint256 gtPerUsdt = gt.gtPerUsdt();
        // GT minted = usdtAmount * gtPerUsdt / 1e18
        // But if both use 18 decimals, multiply then divide by 1e18 to avoid overflow
        uint256 gtAmount = (usdtAmount * gtPerUsdt) / 1e18;

        // pull USDT from buyer
        require(usdt.transferFrom(msg.sender, address(this), usdtAmount), "usdt transfer failed");

        // mint GT to buyer. TokenStore must be owner of GT contract to mint
        gt.mint(msg.sender, gtAmount);

        emit Purchased(msg.sender, usdtAmount, gtAmount);
    }

    // owner/operator withdraw USDT from contract
    function withdrawUsdt(address to, uint256 amount) external onlyOperator {
        require(usdt.transfer(to, amount), "withdraw failed");
    }
}
